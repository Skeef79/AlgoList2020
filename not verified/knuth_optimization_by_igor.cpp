/**
* оптимизация позволяет при решени дп по подотрезкам перейти от куба к квадрату
* То есть пусть у нас есть dp[l][r] = min(dp[l][k] + dp[k][r] + f(l,r,k))
* точка разреза - это такое k, в котором достигается оптимальное значение
* Если выполняется монотонность точки разреза на отрезке, то есть cut[l-1][r] < =cut[l][r] <= cut[l][r+1]
* или что тоже самое что cut[l][r-1] <= cut[l][r] <= cut[l+1][r], то мы можем ходить только между точка разреза и получится квадрат
* если раньше было for k = l .. r, то щас for k = cut[l][r-1] ... cut[l+1][r] и нетрудно видеть что они между собой не пересекаются
* нижу пример простой задачи на эту оптимизацию
*/

const int  N = 410;
ll a[N], dp[N][N], cut[N][N], sum[N][N];

void solve() {
	int n;
	cin >> n;
	for (int i = 0; i < n; i++)
		cin >> a[i];

	for (int i = 0; i < N; i++) {
		ll cur = 0;
		for (int j = i; j < N - 1; j++) {
			cur += a[j];
			dp[i][j] = LINF;
			sum[i][j + 1] = cur;
		}
	}

	for (int i = 0; i < n; i++) {
		dp[i][i + 1] = 0;
		cut[i][i + 1] = i;
	}

	for (int len = 2; len <= n; len++)
		for (int l = 0, r = l + len; l <= n - len; l++, r++)
      //вот тут главное поменять
			for (int k = cut[l][r - 1]; k <= cut[l + 1][r]; k++)
				if (dp[l][k] + dp[k][r] + sum[l][r] < dp[l][r]) {
					dp[l][r] = dp[l][k] + dp[k][r] + sum[l][r];
					cut[l][r] = k;
				}

	cout << dp[0][n];
}
